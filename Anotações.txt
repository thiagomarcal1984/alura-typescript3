Rode npm install para instalar as dependências de package.json.

A estrutura da aplicação mudou: antes a pasta /app era a fonte, e a pasta 
/dist/js era o destino. Agora, a fonte é /app/src e o destino é /app/dist/js.

Um requisito não-funcional para a aplicação é a velocidade do tempo de execução
de certos métodos. Isso pode ser obtido por meio da biblioteca performance:

    public metodo(){
        const t1 = performance.now();
        ... lógica do método ...
        const t2 = performance.now();
        console.log(`Tempo de execução do método: ${(t2-t1)/1000} segundos.`)
    }

MAS essa mensuração invade a lógica de negócio dos métodos. É possível fazer 
essa mensuração de outra forma.

Os decorators do TypeScript podem ajudar na mensuração do tempo de execução.
Decorator é uma função que é executada junto com o método anotado nele:
    @logarTempoDeExecucao() // Use @nome_do_decorator() para decorar o método.
    public adiciona(): void {
        // lógica do método.
    }

Para que o TypeScript permita o uso de decorators, precisamos inserir uma outra
opção no compilador: a experimentalDecorators.

O código ainda não vai compilar, porque a declaração da função do decorator 
está incompleta.

Os decorator, na verdade, precisam retornar uma função com três parâmetros:
    return function (
        target: any, // Recebe o construtor ou o Prototype da classe. 
        propertyKey: string, // Nome do método que será invocado no decorator.
        descriptor: PropertyDescriptor // Objeto para definir o comportamento.
    ) {
        ... corpo da função ...
    }

O parm descriptor nos dá acesso a implementação do método decorado através 
de descriptor.value.

O método apply em uma função recuperada de descriptor.value usa dois 
parâmetros: o contexto onde a função será executada (fornecendo "this", o
próprio objeto que contém o método original será o contexto) e os argumentos
do método (que são obtidos a partir de args, declarado com um spread operator):

O JavaScript não aceita o uso de decorators: isso é uma particularidade do
TypeScript. Quando o .ts é compilado, o .js gerado declara no início do código
uma função que age como o decorator e no fim do código a função é invocada.

A pergunta: o método update em view.ts recebe dois decorators. Como saber 
a ordem de execução deles?

A resposta simples é: o decorator declarado primeiro é executado primeiro.
Mas a mudança do comportamento do método decorado começa a partir do último
decorator declarado.

É a história da pilha de execução: o primeiro decorator roda primeiro, mas 
retorna por último.

Outro raciocínio para exemplificar decorators: 
    class Product {
        @IsGreaterThan('purchasePrice')
        @IsPositive
        @IsNumber
        salesPrice: number
    }

    class Product {
        salesPrice = IsGreaterThan('puchasePrice')(
            IsPositive(
                IsNumber(Product, 'salesPrice')
            )
        )
    }

Se o decorator não tiver parâmetros, você pode declarar diretamente a 
função ao invés de declarar uma função que retorna uma função:
    export function meuDecoratorSimples(
        target: any,
        propertyKey: string,
        descriptor: PropertyDescriptor
    ) {
        ... lógica do decorator simples.
    }

    export function meuDecoratorComplexo() {
        return function(
            target: any,
            propertyKey: string,
            descriptor: PropertyDescriptor
        ) {
            ... lógica do decorator complexo.
        }
    }

    @meuDecoratorSimples
    @meuDecoratorComplexo()
    public metodoDecorado () {
        ... lógica do método decorado.
    }

Perceba que a invocação do decorator está diferente: como ela não é uma 
"função que retorna função", não precisamos de usar parênteses para invocar 
o decorator simplificado.

Por questões de flexibilidade (necessidade de parametrizar o decorator), 
e padronização do formato de invocação dos decorators, recomenda-se usar a 
sintaxe mais complexa (com o wrapper) mesmo.
